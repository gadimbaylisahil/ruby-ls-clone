#!/usr/bin/env ruby

require 'optparse'
require 'open3'
require 'byebug'
require 'pry-byebug'

module LS
  class Application
    FILE_PERMISSIONS_MAP = {
      '7' => 'rwx',
      '6' => 'rw-',
      '5' => 'r-x',
      '4' => 'r--',
      '3' => '-wx',
      '2' => '-w-',
      '1' => '--x'
    }.freeze

    def initialize(argv)
      @params, @files = parse_options(argv)

      @output = {
        block_size: 0,
        permissions: [],
        links: [],
        owners: [],
        groups: [],
        sizes: [],
        modified_dates: [],
        filenames: []
      }
    end

    def run
      unless @files.any?
        Dir.children(Dir.getwd).sort.each do |child|
          next if !@params[:show_all_files] && child[0] == "."

          generate_output(child)
        end
      end
      
      @files.each do |path|
        raise 'No such file or directory' unless (directory?(path) || file?(path))
       
        if directory?(path)
          Dir.children(path).sort.each do |child|
            next if !@params[:show_all_files] && child[0] == "."

            generate_output(child)
          end
        end

        if file?(path)
          generate_output(path)
        end
      end

      render_output
    end

    def render_output
      unless @params[:detailed_output]
        @output[:filenames].each do |filename|
          puts filename
        end

        return
      end
      
      total_files = @output[:filenames].size

      max_links_size = @output[:links].max.to_s.size
      max_owners_size = @output[:owners].max.size
      max_groups_size = @output[:groups].max.size
      max_filesize_size = @output[:sizes].max.to_s.size
      max_modified_dates_size = @output[:modified_dates].max.size
      max_filenames_size = @output[:filenames].max.size
      
      if @params[:detailed_output] && contains_directory?
        puts "total #{@output[:block_size] / 2}"
      end

      0.upto(total_files - 1) do |index|
        puts [
          @output[:permissions][index],
          @output[:links][index].to_s.rjust(max_links_size),
          @output[:owners][index].rjust(max_owners_size),
          @output[:groups][index].rjust(max_groups_size),
          @output[:sizes][index].to_s.rjust(max_filesize_size),
          @output[:modified_dates][index].ljust(max_modified_dates_size),
          @output[:filenames][index]
        ].join(" ")
      end

      return
    end

    def generate_output(filename)
      unless @params[:detailed_output]
        @output[:filenames].push filename
        return
      end
      
      stats = File.stat(filename)
      octal_permissions = stats.mode.to_s(8).split("")[-3..-1]
      
      owner_name = Etc.getpwuid(stats.uid).name
      group_name = Etc.getgrgid(stats.gid).name
      
      file_identifier = File.file?(filename) ? '-' : 'd'
      string_permissions = octal_permissions.map do |permission|
        FILE_PERMISSIONS_MAP.fetch(permission)
      end.join

      size = stats.size
      links = stats.nlink
      modified_date = stats.mtime
      
      @output[:permissions].push(file_identifier + string_permissions)
      @output[:links].push(links)
      @output[:owners].push(owner_name)
      @output[:groups].push(group_name)
      @output[:sizes].push(size)
      @output[:modified_dates].push(modified_date.strftime("%b %d %H:%M"))
      @output[:filenames].push(filename)
      @output[:block_size] += stats.blocks
    end

    private

    def parse_options(argv)
      params = {}
      parser = OptionParser.new

      parser.on("-a") { params[:show_all_files] = true }
      parser.on("-l") { params[:detailed_output] = true }

      directories = parser.parse(argv)

      [params, directories]
    end

    def directory?(path)
      Dir.exists?(path)
    end

    def file?(path)
      File.exists?(path) && File.ftype(path) != 'directory'
    end

    def contains_directory?
      @output[:filenames].any? do |filename|
        Dir.exists?(filename)
      end
    end
  end
end

begin
  LS::Application.new(ARGV).run
rescue => exception
  $stderr.puts "ruby-ls: #{exception.message}"
  exit 1
end
